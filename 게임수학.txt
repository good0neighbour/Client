i)게임 수학(3디 그래픽스 관련) 입문 내용들을 살펴본다

ii) 심플 소프트웨어 엔더러를 만들어본다

iii) directX API 활용법을 살펴보자

좌표계 coordinate system: 물체의 '위치'를 지정하기 위한 시스템

직교좌표계( 데카르트 좌표계 ):
	직교좌표계의 가장 큰 특징은 각각의 기저축들이 직교한다는 것이다
	(원점에서 직교한다 )

	완손좌표계: z축의 양의 방향이 화면 안쪽으로 향한다
	오른손좌표계: z축의 양의 방향이 카메라 안쪽으로 향한다

극좌표계 polar coordinate system

	각도
	거리

	라는 요소로 위치를 표시한다

	x = r * cosT
	y = r * sinT

삼각함수

	삼각형Triangle: 세 개의 정점으로 만들어진 도형

	삼각형의 세 정점은 항상 같은 평면 위에 존재한다는 것이 수학적으로 보장된다.

	법선벡터: 평면의 수직인 단위벡터

	직각삼각형: 삼각비
	<-- 삼각비라는 것은 직각삼각형에서만 성립하는 개념이다. 길에에 대해서 성립

	일반적인 삼각형: 삼각함수
	<--- 정의역, 치역에 들어가는 수가 실수이다. 그러므로 삼각비에서 삼각함수로 개념이 확잘될 수 있었다.

	코사인 법칙: 피타고라스의 정리가 직각삼각형에서만 성립하는 경우라면 코가인 법칙은 모든 일반적인 삼각형에서 성립하는 법칙이다.
	이러한 경우로 인해서 삼각비라는 개념이 삼각함수로 확장된다.

각도의 두 표기

	degree 도:
		원(한 바퀴)를 360등분하여 그 중에 한 조각을 1도로 한다

	radian 호도:
		반지름이 r인 원이 있다면 원주 중에서 r만큼을 1radian이라고 한다.

		<---radian의 경우 원의 개념에서부터 각도의 개념을 이끌어내었기 때문에
		실수의 연산체계에 통합된다.
		그러므로 게임엔진 등에서는 각도를 radian단위로 계산을 한다

	1도 : 360도 = x : 2 * pi

	360도 * x = 1도 * 2 * pi
	x = (1도 * 2 * pi) / 360도

	x = pi / 180도

벡터vector
: '크기'와 '방향'을 아우르는 개념

스칼라scalar
: '크기'만 나타내는 개념

좌표공간에서는 벡터와 위치(점)의 연산이 통합되어 있다.
그래서 점(위치)의 표기법도 벡터를 따른다

벡터의 표기법

i) 수벡터 numeric vector

	(x, y, z) 실수의 순서쌍

	예) (1, 0)

	이 예에서
	크기는 1
	방향은 (1, 0)

ii) 기하벡터 geometry vector

	화살표
	'크기'는 화살표의 길이
	'방향'은 화살표가 지향하는 곳

-기저basis 서로 선형독립인 기저벡터들의 집합
-기저벡터 basis vector: 각각의 축에 가장 기본이 되는 단위벡터
-차원dimension: 기저를 구성하는 기저벡터들의 갯수

단위벡터unit vector: 크기가 1인 벡터

법선벡터normal vector:
평면에 수직인 단위벡터

	게임 프로그래밍에서 많이 다루는 평면의 방정식은
	P dot N + d = 0

연산: '수' 나 '수학적 구조물'의 정체성을 밝히는 도구

벡터의 연산

i) 벡터끼리의 덧셈(뺄셈)

	각각의 구성성분끼리 더한다

	A = (1, 0)
	B = (0, 1)

	A + B = (1, 0) + (0, 1) = (1 + 0, 0 + 1) = (1, 1)

ii) 벡터의 스칼라곱셈(스칼라 배)

	벡터의 각각의 구성성분에 스칼라를 곱한다

	A = (1, 0)
	S = 2

	A * S = (1, 0) * 2 = (1 * 2, 0 * 2) = (2, 0)

iii) 벡터끼리의 곱셈

	가) 내적 dot product

	A dot B = ||A|| ||B|| cosT

	A = (1, 0)
	B = (0, 1)

	A dot B = A.x * B.x + A.y * B.y = 1 * 0 + 0 * 1 = 0

	실제로 프로그램으로 구현할 때는
	아래의 수식을 사용한다.
	왜냐하면, 컴퓨터 입장에서 보면 아래의 수식이 보다 효율적이기 때문이다.
		a) 삼각함수 연산 비용이 없다
		b) 컴퓨터의 기본구조는 가산기이기 때문에 +, *로만 이루어진 식이 더 효율적이다.

	나) 외적 cross product

	A cross B = ||A|| ||B|| sinT U
	( U는 A와 B에 모두 수직인 단위벡터 )

	A = (1, 0, 0) = (A.x, A.y, A.x)
	B = (0, 1, 0) = (B.x, B.y, B.z)

	//3차원의 기저 bais <--기저벡터의 집합
	i = (1, 0, 0)	//x축 기저벡터
	j = (0, 1, 0)	//y축 기저벡터
	k = (0, 0, 1)	//z축 기저벡터

	A cross B = (A.y * B.z - A.z * B.y) * i + (A.z * B.x - A.x * B.z) * j + (A.x * B.y - A.y * B.x) * k

		= (0 * 0 - 0 * 1) * i + (0 * 0 - 1 * 0) * j + (1 * 1 - 0 * 0) * k
		= 0 * i + 0 * j + 1 * k
		= 1 * (0, 0, 1)
		= (0, 0, 1)

iv) 크기 : 자기자신을 내적해서 제곱근을 취한다

v) 정규화: 벡터의 크기를 1로 만드는 연산

내적의 응용 예

: 두 벡터의 위치 관계를 대수적으로 판단한다.

일단 두 벡터는 단위벡터라고 가정한다

	i)내적의 결과값 = 0
	두 벡터의 위치관계는 수직이다

	ii)내적의 결과값 = 1
	두 벡터의 위치관계는 같은 방향이다

	iii)내적의 결과값 = -1
	두 벡터의 위치관계는 반대 방향이다

	iv)내적의 결과값이 양수이 0과 1 사이다
	두 벡터의 위치관계는 예각이다

	v)내적의 결과값이 음수고 -1과 0 사이다
	두 벡터의 위치관계는 둔각이다

외적의 응용 예

	평면의 법선벡터를 구할 수 있다

'좌표공간'에서는 '벡터'와 '위치'(점)의 '연산이 통합'되어 있다.
그래서 점(위치)의 표기법도 벡터를 따른다